#include <assert.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include "gattlib.h"
#include <string.h>
#include <time.h>

typedef enum { READ, WRITE} operation_t;
operation_t g_operation;

static bt_uuid_t g_uuid;
long int value_data;

struct timespec start_time;
struct timespec end_time;
struct timespec time_difference;
struct timespec gettime_now;
long int final_time;

FILE *fp;

//timespec diff(timespec start, timespec end);

static void usage(char *argv[]) {
	printf("%s <device_address> <read|write> <uuid> [<hex-value-to-write>]\n", argv[0]);
	printf("Test");
}

struct timespec diff(struct timespec start, struct timespec end){
    struct timespec temp;

    if ((end.tv_nsec-start.tv_nsec)<0)
    {
            temp.tv_sec = end.tv_sec-start.tv_sec-1;
            temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;
    }
    else 
    {
            temp.tv_sec = end.tv_sec-start.tv_sec;
            temp.tv_nsec = end.tv_nsec-start.tv_nsec;
    }
    return temp;
}

float sensorMpu9250GyroConvert(int16_t data){
        return(data * 1.0) / (65536/500);
}

void notification_handler(uint16_t status_handle, const int8_t* data, size_t data_length, void* user_data) {
	int i;
	//FILE *fp;
	time_t ltime;
        ltime = time(NULL);
	fp = fopen("movement.csv","a");
	//fprintf(fp,"Notification handle = 0x%04x \n value: ",status_handle);
	g_print("Notification handle = 0x%04x value: ",status_handle);

	//fprintf(fp,"%s",asctime(localtime(&ltime)));
	
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID,&end_time);
	time_difference = diff(start_time,end_time);

	for (i = 0; i < data_length; i++){
		//fprintf(fp,"%02x ",data[i]);
		g_print("%02x ", data[i]);
	}
	//fprintf(fp,"\n");
	int16_t rawgx[2] = {(int16_t)data[0]};
	int16_t rawgy[2] = {(int16_t)data[1]};
	int16_t rawgz[2] = {(int16_t)data[2]};
	int16_t rawax[2] = {(int16_t)data[3]};
 	int16_t raway[2] = {(int16_t)data[4]};	
 	int16_t rawaz[2] = {(int16_t)data[5]};
 	int16_t rawmx[2] = {(int16_t)data[6]};
	int16_t rawmy[2] = {(int16_t)data[7]};
        int16_t rawmz[2] = {(int16_t)data[8]};
	int16_t gx = (rawgx[1]<<8) + rawgx[0];
	int16_t gy = (rawgy[1]<<8) + rawgy[0];
	int16_t gz = (rawgz[1]<<8) + rawgz[0];
	int16_t ax = (rawax[1]<<8) + rawax[0];
	int16_t ay = (raway[1]<<8) + raway[0];
	int16_t az = (rawaz[1]<<8) + rawaz[0];
	int16_t mx = (rawmx[1]<<8) + rawmx[0];
	int16_t my = (rawmy[1]<<8) + rawmy[0];
	int16_t mz = (rawmz[1]<<8) + rawmz[0];
	//float gx = sensorMpu9250GyroConvert(x);
	fprintf(fp,"%d,%d,%d,%d,%d,%d,%d,%d,%d",gx,gy,gz,ax,ay,az,mx,my,mz);
	g_print("%d %d %d",gx,gy,gz);

	//fprintf(fp,"Time: %d ms\n", (time_difference.tv_sec * 1000) + (time_difference.tv_nsec/1000000));
	fprintf(fp,"\n");
	fclose(fp);
	g_print("\n");
}

void create_csv(char *filename,uint8_t data[12], int len){
	printf("\n Creating %s.csv file",filename);
	//FILE *fp;
	int i;
	//filename = strcat(filename,".csv");
	//fp=fopen("test10.csv","a");

        fprintf(fp,"Read UUID completed: ");
        for (i = 0; i < len; i++)
		fprintf(fp,"%02x ", data[i]);
        fprintf(fp,"\n");
        fclose(fp);
}


void timestamp(){
	time_t ltime;
	ltime = time(NULL);
	printf("%s",asctime(localtime(&ltime)));
}
int main(int argc, char *argv[]) {
	uint8_t buffer[100];
	int i, len, ret;
	char str[100];
	gatt_connection_t* connection;
	uint16_t status_handle, handle;

	connection = gattlib_connect(NULL, argv[1], BDADDR_LE_PUBLIC, BT_IO_SEC_LOW, 0, 0);
	if (connection == NULL) {
                fprintf(stderr, "Fail to connect to the bluetooth device.\n");
                return 1;
        }
	printf("connection ok");
	//status_handle = 0x22;
	handle = strtoimax(argv[2], NULL,16);
	status_handle = strtoimax(argv[3], NULL, 16);
	uint16_t enable_sensor = strtoimax(argv[4],NULL,16);
	uint16_t enable_notification = strtoimax(argv[5],NULL,16);//or 0001
	printf("writing");
	int a = 0;
	//while(1){
	gattlib_write_char_by_handle(connection, handle,&enable_sensor,sizeof(enable_sensor));
	bt_string_to_uuid(&g_uuid, "f000aa81-0451-4000-b000-000000000000");
	len = gattlib_read_char_by_uuid(connection, &g_uuid, buffer, sizeof(buffer));	
	printf("%18x ",buffer[i]); 
        printf("Read UUID completed: ");
                for (i = 0; i < len; i++)
                       printf("%02x ", buffer[i]);
        printf("\n");
	float gy = sensorMpu9250GyroConvert(buffer[1]);
	float gz = sensorMpu9250GyroConvert(buffer[2]);
	printf("%f %f",gy,gz);
	printf("yay");
	printf("\n");
	printf("Time: ");
	timestamp();
	printf("\n");
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start_time);
	//start_time = gettime_now.tv_nsec ;
	
	while(1){
	gattlib_write_char_by_handle(connection, status_handle, &enable_notification, sizeof(enable_notification));

	gattlib_register_notification(connection, notification_handler, NULL);

//	create_csv(str,buffer,len);
	//a++;
	}
	//printf("\n %s file created", str);
	return 0;
	/*uint16_t handle = strtoimax(argv[2], NULL, 16);
	printf("TRY PRINTING");
	printf("%02x ", handle);
	uint8_t  value = strtoimax(argv[3], NULL, 16);
	printf("value written: %d\n", value);
	gattlib_register_notification(connection,notification_handler,NULL);
		gattlib_write_char_by_handle(connection, handle, &value, sizeof(value));
		printf("endddddd");

		/*len = gattlib_read_char_by_uuid(connection, &g_uuid, buffer, sizeof(buffer));
		printf("Reading UUID completed: ");
		for (i = 0; i < len; i++)
                        printf("%02x ", buffer[i]);
                printf("\n");

////yang di atas udah bener semuaaaaaaaaaaaa///////////



	/*if ((argc != 4) && (argc != 5)) {
		usage(argv);
		return 1;
	}*/
/////use the one below for testing/////////
/*	if (strcmp(argv[2], "read") == 0) {
		g_operation = READ;
	} else if ((strcmp(argv[2], "write") == 0)) {
		g_operation = WRITE;

		if ((strlen(argv[4]) >= 2) && (argv[4][0] == '0') && (argv[4][0] == 'x')) {
			value_data = strtol(argv[4], NULL, 0);
		} else {
			value_data = strtol(argv[4], NULL, 16);
		}
		printf("Value to write: 0x%lx\n", value_data);
	} else {
		usage(argv);
		//return 1;
	}

	if (bt_string_to_uuid(&g_uuid, argv[3]) < 0) {
		usage(argv);
		//return 1;
	}

	connection = gattlib_connect(NULL, argv[1], BDADDR_LE_PUBLIC, BT_IO_SEC_LOW, 0, 0);
	if (connection == NULL) {
		fprintf(stderr, "Fail to connect to the bluetooth device.\n");
		return 1;
	}

	if (g_operation == READ) {
		len = gattlib_read_char_by_uuid(connection, &g_uuid, buffer, sizeof(buffer));
		printf("Read UUID completed UAUAUAU: ");
		for (i = 0; i < len; i++)
			printf("%02x ", buffer[i]);
		printf("\n");
	} else if(g_operation == WRITE) {
		uint16_t handle = strtoimax(argv[3], NULL, 16);
		printf("TRY PRINTING");
		printf("%02x ", handle);
		uint16_t  value = strtoimax(argv[4], NULL, 16);
		printf("value written: %d\n", value);

		gattlib_write_char_by_handle(connection, handle, &value, sizeof(value));
		printf("endddddd");
		bt_string_to_uuid(&g_uuid,"f000aa81-0451-4000-b000-000000000000");
		len = gattlib_read_char_by_uuid(connection, &g_uuid, buffer, sizeof(buffer));
		printf("Reading UUID completed: ");
		for (i = 0; i < len; i++)
                        printf("%02x ", buffer[i]);
                printf("\n");

	}

	gattlib_disconnect(connection);
	return 0;*/
}
